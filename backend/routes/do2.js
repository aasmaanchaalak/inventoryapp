const express = require('express');
const PDFDocument = require('pdfkit');
const router = express.Router();
const DO2 = require('../models/DO2');
const DO1 = require('../models/DO1');
const PurchaseOrder = require('../models/PurchaseOrder');
const Lead = require('../models/Lead');
const { sendDO2ExecutionNotification } = require('../services/smsService');

// POST /api/do2 - Create a new DO2 (auto-generated after DO1)
router.post('/', async (req, res) => {
  try {
    const { do1Id, poId, remainingQuantities } = req.body;

    // Validate required fields
    if (!do1Id || !poId || !remainingQuantities) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: do1Id, poId, remainingQuantities',
      });
    }

    // Validate that DO1 exists
    const do1 = await DO1.findById(do1Id);
    if (!do1) {
      return res.status(404).json({
        success: false,
        message: 'DO1 not found',
      });
    }

    // Validate that PO exists
    const purchaseOrder = await PurchaseOrder.findById(poId);
    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase Order not found',
      });
    }

    // Filter items with remaining quantities > 0
    const itemsWithRemaining = remainingQuantities.filter(
      (item) => item.remainingQuantity > 0
    );

    if (itemsWithRemaining.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No remaining quantities to create DO2',
      });
    }

    // Determine status and auto-approve if PO is admin-approved
    let status = 'draft';
    let approvalStatus = {
      isApproved: false,
      approvedBy: null,
      approvedAt: null,
      approvedQuantity: 0,
      remarks: '',
    };

    if (purchaseOrder.approvalStatus === 'approved') {
      status = 'approved'; // Auto-approve DO2
      approvalStatus = {
        isApproved: true,
        approvedBy: 'System (Auto-approval)',
        approvedAt: new Date(),
        approvedQuantity: itemsWithRemaining.reduce(
          (sum, item) => sum + item.remainingQuantity,
          0
        ),
        remarks: 'Auto-approved due to PO approval',
      };
    }

    // Create the DO2
    const do2 = new DO2({
      poId,
      do1Id,
      status,
      approvalStatus,
      items: itemsWithRemaining,
      autoGenerated: true,
    });

    await do2.save();

    // Populate references for response
    await do2.populate([
      { path: 'poId', select: 'poNumber leadId totalAmount' },
      { path: 'do1Id', select: 'doNumber dispatchDate' },
    ]);

    res.status(201).json({
      success: true,
      message: 'DO2 created successfully',
      data: {
        _id: do2._id,
        do2Number: do2.do2Number,
        poId: do2.poId,
        do1Id: do2.do1Id,
        status: do2.status,
        totalItems: do2.items.length,
        totalRemainingQuantity: do2.totalRemainingQuantity,
      },
    });
  } catch (error) {
    console.error('Error creating DO2:', error);

    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map((err) => err.message);
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors,
      });
    }

    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'DO2 with this number already exists',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// GET /api/do2/:poId - Get DO2 status and approval flow for a PO
router.get('/:poId', async (req, res) => {
  try {
    const { poId } = req.params;

    // Validate that PO exists
    const purchaseOrder = await PurchaseOrder.findById(poId);
    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase Order not found',
      });
    }

    // Find all DO2s for this PO
    const do2s = await DO2.find({ poId })
      .populate('do1Id', 'doNumber dispatchDate status')
      .populate('poId', 'poNumber leadId totalAmount approvalStatus')
      .sort({ createdAt: -1 });

    // Get the latest DO2
    const latestDO2 = do2s.length > 0 ? do2s[0] : null;

    // Format response data
    const responseData = {
      poDetails: {
        poNumber: purchaseOrder.poNumber,
        approvalStatus: purchaseOrder.approvalStatus,
        totalAmount: purchaseOrder.totalAmount,
        leadId: purchaseOrder.leadId,
      },
      do2Status: {
        hasDO2: do2s.length > 0,
        totalDO2s: do2s.length,
        latestDO2: latestDO2
          ? {
              do2Number: latestDO2.do2Number,
              status: latestDO2.status,
              createdAt: latestDO2.createdAt,
              totalRemainingQuantity: latestDO2.totalRemainingQuantity,
              approvalStatus: latestDO2.approvalStatus,
            }
          : null,
      },
      approvalFlow: {
        currentStep: latestDO2 ? latestDO2.status : 'no_do2',
        nextStep: getNextApprovalStep(latestDO2, purchaseOrder.approvalStatus),
        requiresApproval: latestDO2 && latestDO2.status === 'pending_approval',
        canExecute: latestDO2 && latestDO2.status === 'approved',
      },
      allDO2s: do2s.map((do2) => ({
        do2Number: do2.do2Number,
        status: do2.status,
        createdAt: do2.createdAt,
        totalRemainingQuantity: do2.totalRemainingQuantity,
        approvalStatus: do2.approvalStatus,
        do1Number: do2.do1Id.doNumber,
      })),
    };

    res.json({
      success: true,
      message: 'DO2 status retrieved successfully',
      data: responseData,
    });
  } catch (error) {
    console.error('Error fetching DO2 status:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid PO ID',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// Helper function to determine next approval step
const getNextApprovalStep = (latestDO2, poApprovalStatus) => {
  if (!latestDO2) return 'create_do2';

  switch (latestDO2.status) {
    case 'draft':
      return poApprovalStatus === 'approved'
        ? 'pending_approval'
        : 'wait_for_po_approval';
    case 'pending_approval':
      return 'approved';
    case 'approved':
      return 'execute';
    case 'executed':
      return 'completed';
    case 'rejected':
      return 'revise_do2';
    default:
      return 'unknown';
  }
};

// PUT /api/do2/:id/approve - Approve a DO2
router.put('/:id/approve', async (req, res) => {
  try {
    const { id } = req.params;
    const { approvedBy, approvedQuantity, remarks } = req.body;

    const do2 = await DO2.findById(id);
    if (!do2) {
      return res.status(404).json({
        success: false,
        message: 'DO2 not found',
      });
    }

    if (do2.status !== 'pending_approval') {
      return res.status(400).json({
        success: false,
        message: 'DO2 is not in pending approval status',
      });
    }

    // Update approval status
    do2.status = 'approved';
    do2.approvalStatus = {
      isApproved: true,
      approvedBy: approvedBy || 'System',
      approvedAt: new Date(),
      approvedQuantity: approvedQuantity || do2.totalRemainingQuantity,
      remarks: remarks || '',
    };

    await do2.save();

    res.json({
      success: true,
      message: 'DO2 approved successfully',
      data: {
        do2Number: do2.do2Number,
        status: do2.status,
        approvalStatus: do2.approvalStatus,
      },
    });
  } catch (error) {
    console.error('Error approving DO2:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid DO2 ID',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// PUT /api/do2/:id/reject - Reject a DO2
router.put('/:id/reject', async (req, res) => {
  try {
    const { id } = req.params;
    const { rejectedBy, remarks } = req.body;

    const do2 = await DO2.findById(id);
    if (!do2) {
      return res.status(404).json({
        success: false,
        message: 'DO2 not found',
      });
    }

    if (do2.status !== 'pending_approval') {
      return res.status(400).json({
        success: false,
        message: 'DO2 is not in pending approval status',
      });
    }

    // Update status to rejected
    do2.status = 'rejected';
    do2.approvalStatus = {
      isApproved: false,
      approvedBy: null,
      approvedAt: null,
      approvedQuantity: 0,
      remarks: remarks || 'Rejected by approver',
    };

    await do2.save();

    res.json({
      success: true,
      message: 'DO2 rejected successfully',
      data: {
        do2Number: do2.do2Number,
        status: do2.status,
        approvalStatus: do2.approvalStatus,
      },
    });
  } catch (error) {
    console.error('Error rejecting DO2:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid DO2 ID',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// PUT /api/do2/:id/execute - Execute DO2 and update inventory
router.put('/:id/execute', async (req, res) => {
  try {
    const { id } = req.params;
    const { executedBy, remarks } = req.body;

    const do2 = await DO2.findById(id)
      .populate('poId', 'poNumber leadId totalAmount')
      .populate('do1Id', 'doNumber dispatchDate');

    if (!do2) {
      return res.status(404).json({
        success: false,
        message: 'DO2 not found',
      });
    }

    if (do2.status !== 'approved') {
      return res.status(400).json({
        success: false,
        message: 'DO2 must be approved before execution',
      });
    }

    // Update inventory for each item
    const inventoryUpdates = [];
    for (const item of do2.items) {
      try {
        // Mock inventory update - replace with actual inventory API
        const inventoryUpdate = await updateInventory(item);
        inventoryUpdates.push(inventoryUpdate);
      } catch (inventoryError) {
        console.error(
          `Error updating inventory for item ${item.itemId}:`,
          inventoryError
        );
        return res.status(500).json({
          success: false,
          message: `Failed to update inventory for ${item.type} ${item.size}`,
          error: inventoryError.message,
        });
      }
    }

    // Update DO2 status to executed
    do2.status = 'executed';
    do2.executionDetails = {
      executedBy: executedBy || 'System',
      executedAt: new Date(),
      remarks: remarks || 'DO2 executed successfully',
      inventoryUpdates: inventoryUpdates,
    };

    await do2.save();

    // Send SMS notification
    try {
      // Get lead information for SMS
      const lead = await Lead.findById(do2.poId.leadId);
      if (lead && lead.phone) {
        const smsResult = await sendDO2ExecutionNotification(
          lead.phone,
          lead.name || 'Customer',
          do2.do2Number,
          process.env.COMPANY_NAME || 'Your Company'
        );

        console.log('SMS notification result:', smsResult);

        // Add SMS details to execution details
        do2.executionDetails.smsNotification = {
          sent: smsResult.success,
          messageId: smsResult.messageId,
          sentAt: new Date(),
          error: smsResult.error || null,
        };

        await do2.save();
      } else {
        console.log('SMS notification skipped: No lead phone number found');
      }
    } catch (smsError) {
      console.error('SMS notification failed:', smsError);
      // Don't fail the execution if SMS fails
    }

    res.json({
      success: true,
      message: 'DO2 executed successfully',
      data: {
        do2Number: do2.do2Number,
        status: do2.status,
        executionDetails: do2.executionDetails,
        totalItemsExecuted: do2.items.length,
        totalQuantityExecuted: do2.items.reduce(
          (sum, item) => sum + item.remainingQuantity,
          0
        ),
      },
    });
  } catch (error) {
    console.error('Error executing DO2:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid DO2 ID',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// Real function to update inventory
const updateInventory = async (item) => {
  try {
    const Inventory = require('../models/Inventory');

    // Find or create inventory item
    const inventory = await Inventory.findOrCreate({
      productType: item.type,
      size: item.size,
      thickness: item.thickness,
      rate: item.rate,
      hsnCode: item.hsnCode,
    });

    // Update stock (reduce by remaining quantity)
    const result = await inventory.updateStock(
      item.remainingQuantity,
      'out',
      `DO2-${item.do2Number || 'EXECUTION'}`,
      'DO2 execution - stock reduction'
    );

    return {
      itemId: inventory._id,
      type: item.type,
      size: item.size,
      thickness: item.thickness,
      quantityReduced: item.remainingQuantity,
      oldStockLevel: result.oldQuantity,
      newStockLevel: result.newQuantity,
      updatedAt: new Date(),
      transactionId: result.reference,
    };
  } catch (error) {
    console.error('Error updating inventory:', error);
    throw error;
  }
};

// GET /api/do2/:id - Get a specific DO2
router.get('/:id', async (req, res) => {
  try {
    const do2 = await DO2.findById(req.params.id)
      .populate('poId', 'poNumber leadId totalAmount approvalStatus')
      .populate('do1Id', 'doNumber dispatchDate status');

    if (!do2) {
      return res.status(404).json({
        success: false,
        message: 'DO2 not found',
      });
    }

    res.json({
      success: true,
      data: do2,
    });
  } catch (error) {
    console.error('Error fetching DO2:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid DO2 ID',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message,
    });
  }
});

// GET /api/do2/calendar - Get all DO2s for calendar display
router.get('/calendar', async (req, res) => {
  try {
    const { status, startDate, endDate } = req.query;

    // Build filter object
    const filter = {};

    // Filter by status if provided
    if (status) {
      if (status === 'pending') {
        filter.status = { $in: ['pending_approval', 'approved'] };
      } else {
        filter.status = status;
      }
    } else {
      // Default: get pending and approved DO2s
      filter.status = { $in: ['pending_approval', 'approved'] };
    }

    // Filter by date range if provided
    if (startDate || endDate) {
      filter.targetDispatchDate = {};
      if (startDate) filter.targetDispatchDate.$gte = new Date(startDate);
      if (endDate) filter.targetDispatchDate.$lte = new Date(endDate);
    }

    // Fetch DO2s with populated data
    const do2s = await DO2.find(filter)
      .populate({
        path: 'poId',
        select: 'poNumber leadId totalAmount',
        populate: {
          path: 'leadId',
          select: 'name phone product source',
        },
      })
      .populate('do1Id', 'doNumber dispatchDate status')
      .sort({ targetDispatchDate: 1, createdAt: -1 });

    // Format data for calendar
    const calendarData = do2s.map((do2) => {
      // Get customer name from lead
      const customerName = do2.poId?.leadId?.name || 'Unknown Customer';
      const productType = do2.poId?.leadId?.product || 'Steel Tubes';

      // Calculate total dispatch quantity
      const totalDispatchQuantity = do2.items.reduce(
        (sum, item) => sum + item.remainingQuantity,
        0
      );

      // Determine event date (target dispatch date or creation date)
      const eventDate = do2.targetDispatchDate || do2.createdAt;

      // Determine status for calendar
      let calendarStatus = 'pending';
      if (do2.status === 'approved') {
        calendarStatus = 'approved_not_executed';
      } else if (do2.status === 'executed') {
        calendarStatus = 'executed';
      } else if (do2.status === 'rejected') {
        calendarStatus = 'rejected';
      }

      return {
        id: do2._id,
        do2Number: do2.do2Number,
        customerName: customerName,
        customerPhone: do2.poId?.leadId?.phone || '',
        productType: productType,
        productSource: do2.poId?.leadId?.source || '',
        poNumber: do2.poId?.poNumber || '',
        do1Number: do2.do1Id?.doNumber || '',
        status: do2.status,
        calendarStatus: calendarStatus,
        targetDispatchDate: do2.targetDispatchDate,
        createdAt: do2.createdAt,
        totalDispatchQuantity: totalDispatchQuantity,
        totalAmount: do2.poId?.totalAmount || 0,
        items: do2.items.map((item) => ({
          type: item.type,
          size: item.size,
          thickness: item.thickness,
          remainingQuantity: item.remainingQuantity,
          rate: item.rate,
          hsnCode: item.hsnCode,
        })),
        approvalStatus: do2.approvalStatus,
        remarks: do2.remarks,
        autoGenerated: do2.autoGenerated,
      };
    });

    // Calculate summary statistics
    const summary = {
      total: calendarData.length,
      pendingApproval: calendarData.filter(
        (d) => d.status === 'pending_approval'
      ).length,
      approved: calendarData.filter((d) => d.status === 'approved').length,
      executed: calendarData.filter((d) => d.status === 'executed').length,
      rejected: calendarData.filter((d) => d.status === 'rejected').length,
      totalQuantity: calendarData.reduce(
        (sum, d) => sum + d.totalDispatchQuantity,
        0
      ),
      totalValue: calendarData.reduce((sum, d) => sum + d.totalAmount, 0),
    };

    res.json({
      success: true,
      message: 'Calendar data retrieved successfully',
      data: {
        do2s: calendarData,
        summary: summary,
        filters: {
          status: status || 'pending',
          startDate: startDate || null,
          endDate: endDate || null,
        },
      },
    });
  } catch (error) {
    console.error('Error fetching calendar data:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching calendar data',
      error: error.message,
    });
  }
});

// GET /api/do2/:id/pdf - Generate DO2 PDF
router.get('/:id/pdf', async (req, res) => {
  try {
    const { id } = req.params;

    // Validate DO2 ID
    if (!id) {
      return res.status(400).json({
        success: false,
        message: 'DO2 ID is required',
      });
    }

    // Fetch DO2 with populated data
    const do2 = await DO2.findById(id)
      .populate({
        path: 'poId',
        populate: {
          path: 'leadId',
          select: 'name phone product source',
        },
      })
      .populate('do1Id', 'doNumber dispatchDate');

    if (!do2) {
      return res.status(404).json({
        success: false,
        message: 'DO2 not found',
      });
    }

    // Create PDF document
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="delivery-order-2-${do2.do2Number}.pdf"`
    );

    // Pipe PDF to response
    doc.pipe(res);

    // Add company header
    doc.fontSize(24).font('Helvetica-Bold').text('Vikash Steel Tubes.', 50, 50);

    doc
      .fontSize(10)
      .font('Helvetica')
      .text('Industrial Steel Tube Manufacturer', 50, 80)
      .text('GST: 06XXXXX1234X1Z5', 50, 95)
      .text('Email: dispatch@steeltubes.com | Phone: +91-XXXXX-XXXXX', 50, 110);

    // Add document title
    doc
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('DELIVERY ORDER 2 (DO2)', 50, 150);

    // Add DO2 details
    doc
      .fontSize(12)
      .font('Helvetica')
      .text(`DO2 Number: ${do2.do2Number}`, 50, 190)
      .text(
        `DO2 Date: ${new Date(do2.dispatchDate).toLocaleDateString('en-IN')}`,
        50,
        210
      )
      .text(`Status: ${do2.status.toUpperCase()}`, 50, 230)
      .text(`PO Reference: ${do2.poId.poNumber}`, 50, 250)
      .text(`DO1 Reference: ${do2.do1Id.doNumber}`, 50, 270);

    // Add customer details
    doc.fontSize(14).font('Helvetica-Bold').text('Customer Details:', 50, 310);

    doc
      .fontSize(12)
      .font('Helvetica')
      .text(`Name: ${do2.poId.leadId.name}`, 50, 335)
      .text(`Phone: ${do2.poId.leadId.phone}`, 50, 355)
      .text(`Product: ${do2.poId.leadId.product}`, 50, 375);

    // Add dispatch summary
    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Final Dispatch Summary:', 300, 310);

    const totalDispatched = do2.items.reduce(
      (sum, item) => sum + item.dispatchedQuantity,
      0
    );
    const totalValue = do2.items.reduce(
      (sum, item) => sum + item.dispatchedQuantity * item.rate,
      0
    );

    doc
      .fontSize(12)
      .font('Helvetica')
      .text(`Total Items: ${do2.items.length}`, 300, 335)
      .text(`Total Quantity: ${totalDispatched.toFixed(2)} tons`, 300, 355)
      .text(`Total Value: ₹${totalValue.toLocaleString('en-IN')}`, 300, 375);

    // Add execution status if executed
    if (do2.status === 'executed' && do2.executionDetails) {
      const executedDate = new Date(
        do2.executionDetails.executedAt
      ).toLocaleDateString('en-IN');
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text(`✓ EXECUTED on ${executedDate}`, 300, 395);
    }

    // Add items table
    let yPosition = 430;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Final Dispatch Items:', 50, yPosition);

    yPosition += 30;

    // Table headers and column positions
    const tableHeaders = [
      'Type',
      'Size',
      'Thickness',
      'Remaining',
      'Dispatched',
      'Rate',
      'Value',
    ];
    const columnPositions = [50, 120, 190, 260, 320, 380, 450];

    // Draw table headers
    doc.fontSize(10).font('Helvetica-Bold');
    tableHeaders.forEach((header, index) => {
      doc.text(header, columnPositions[index], yPosition);
    });

    // Draw header line
    yPosition += 20;
    doc.moveTo(50, yPosition).lineTo(550, yPosition).stroke();
    yPosition += 10;

    // Add items
    doc.fontSize(9).font('Helvetica');
    do2.items.forEach((item) => {
      const itemValue = item.dispatchedQuantity * item.rate;
      const itemData = [
        item.type,
        item.size,
        `${item.thickness}mm`,
        `${item.remainingQuantity}`,
        `${item.dispatchedQuantity}`,
        `₹${item.rate.toLocaleString('en-IN')}`,
        `₹${itemValue.toLocaleString('en-IN')}`,
      ];

      itemData.forEach((data, index) => {
        doc.text(data, columnPositions[index], yPosition);
      });

      yPosition += 20;
    });

    // Draw total line
    doc.moveTo(50, yPosition).lineTo(520, yPosition).stroke();
    yPosition += 15;

    // Add totals
    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .text(
        `Total Dispatched: ${totalDispatched.toFixed(2)} tons`,
        300,
        yPosition
      )
      .text(
        `Total Value: ₹${totalValue.toLocaleString('en-IN')}`,
        300,
        yPosition + 20
      );

    // Add remarks if any
    if (do2.remarks) {
      yPosition += 60;
      doc.fontSize(12).font('Helvetica-Bold').text('Remarks:', 50, yPosition);

      doc
        .fontSize(10)
        .font('Helvetica')
        .text(do2.remarks, 50, yPosition + 20, { width: 500 });
    }

    // Add important notes
    yPosition += 80;
    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .text('Important Notes:', 50, yPosition);

    doc
      .fontSize(10)
      .font('Helvetica')
      .text('• This is the final delivery order (DO2)', 50, yPosition + 20)
      .text('• This completes the full order dispatch', 50, yPosition + 35)
      .text(
        '• Invoice will be generated after DO2 execution',
        50,
        yPosition + 50
      )
      .text('• Please check quantities upon receipt', 50, yPosition + 65);

    // Add execution details if executed
    if (do2.status === 'executed' && do2.executionDetails) {
      yPosition += 100;
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text('Execution Details:', 50, yPosition);

      doc
        .fontSize(10)
        .font('Helvetica')
        .text(
          `Executed At: ${new Date(do2.executionDetails.executedAt).toLocaleString('en-IN')}`,
          50,
          yPosition + 20
        )
        .text(
          `Executed By: ${do2.executionDetails.executedBy || 'System'}`,
          50,
          yPosition + 35
        )
        .text('✓ Order completed successfully', 50, yPosition + 50)
        .text('✓ SMS notification sent to customer', 50, yPosition + 65)
        .text('✓ Invoice generated and ready for download', 50, yPosition + 80);
    }

    // Add footer
    const footerY = 750;
    doc
      .fontSize(10)
      .font('Helvetica')
      .text('Vikash Steel Tubes. - Final Delivery Order', 50, footerY)
      .text(
        `Generated on: ${new Date().toLocaleDateString('en-IN')}`,
        400,
        footerY
      );

    // Finalize PDF
    doc.end();
  } catch (error) {
    console.error('Error generating DO2 PDF:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating PDF',
      error: error.message,
    });
  }
});

module.exports = router;
